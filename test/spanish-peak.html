<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Testing Kepler</title>
    <script src='/devs/workspace/packages/dataframe/dist/@youwol/dataframe.js'></script>
    <script src='/devs/workspace/packages/math/dist/@youwol/math.js'></script>
    <script src='/devs/workspace/packages/geometry/dist/@youwol/geometry.js'></script>
    <script src='/devs/workspace/packages/io/dist/@youwol/io.js'></script>
    <script src='/devs/workspace/packages/mesh.js'></script>

    <script src='/devs/workspace/packages/three-extra/node_modules/three/build/three.min.js'></script>
    <script src='/devs/workspace/packages/three-extra/dist/@youwol/three-extra.js'></script>
    <script src='/devs/workspace/packages/kepler/dist/@youwol/kepler.js'></script>
    
    <script src="https://kit.fontawesome.com/daa834e337.js" crossorigin="anonymous"></script>

    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="loading" id="js-loader">
        <div class="loader"></div>
    </div>

    <div class='home-container'>
        <span>
            <div class='buttonIcon'>
                <div id='goHome'><i class='fa fa-home'></i></div>
            </div>
            <div class='buttonIcon'>
                <div id='saveHome'><i class='fa fa-clinic-medical'></i></div>
            </div>
            <div class='right-container'>
                <div id='orientCubeWrapper'></div>
            </div>
        </span>
    </div>

    <script>

        // let params = (new URL(document.location)).searchParams
        // let token = params.get("model")
        // console.log('---------->', token)

        const three     = globalThis['THREE']
        
        const dataframe = globalThis['@youwol/dataframe']
        const math      = globalThis['@youwol/math']
        const geometry  = globalThis['@youwol/geometry']

        const io        = globalThis['@youwol/io']

        const extra     = globalThis['@youwol/three-extra']
        const kepler    = globalThis['@youwol/kepler']

        let mesh        = undefined 
        let cube        = undefined
        
        globalThis['MeshModule']().then( m => {
            mesh = m
        }).then( _ => {
            //console.log(mesh)
            ALL() ;
        })

        // ================================
        const showDikes     = false
        const showGrid      = false
        const showChambers  = true
        const showPlanes    = true
        // ================================

        const surfaceset = [
                {
                    url: "/data/arch/spanish-peak/forward-grid.ts",
                    show: true,
                    attr: '',
                    lut: 'Insar',
                    duplicateLut: 1,
                    surface: {
                        show: true,
                        color: '#aaaaaa',
                        flat: false,
                        creaseAngle: 0,
                        opacity: 0.5
                    },
                    iso: {
                        show: false,
                        showFill: true,
                        showLines: true,
                        flat: true,
                        nb :   20,
                        useMinMax: false,
                        min: -1e10,
                        max:  1e10,
                    },
                    vectors: {
                        show: true,
                        attr: 'Joint',
                        scale: 500,
                        color: '#000000',
                        useTube: false,
                        radius: 20
                    },
                    borders: {
                        show: true,
                        color: "#000000"
                    },
                    wireframe: {
                        show: false,
                        color: '#000000'
                    },
                    failure: {
                        show: false,
                        stress: 'S',
                        //sizeAttribute: 'S1',
                        //paintAttribute: 'S1',
                        size: 25,
                        color: '#ffff00',
                        circle: false,
                        borders: true,
                        type: kepler.FractureType.DYKE
                    }
                },
                {
                    url: "/data/arch/spanish-peak/simulations-cavity.ts",
                    show: true,
                    attr: '',
                    lut: 'Insar',
                    duplicateLut: 1,
                    surface: {
                        show: true,
                        color: '#ff0000',
                        flat: false,
                        creaseAngle: 0,
                        opacity: 1
                    },
                    iso: {
                        show: false,
                        showFill: true,
                        showLines: false,
                        flat: true,
                        nb :   20,
                        useMinMax: false,
                        min: -1e10,
                        max:  1e10,
                    }
                }
            ]

            const plines = [
                {
                    url: [ 
                        '/data/arch/spanish-peak/dykes.pl'
                    ],
                    show: true,
                    useTube: true,
                    tubeRadius: 30,
                    color: "#ffffff"
                }
            ]

            const pointsets = [
                {
                    url: "/data/arch/spanish-peak/result-forward-dikes.xyz",
                    show: false,
                    attr: '',
                    lut: 'Insar',
                    reverseLut: false,
                    size: 4,
                    min: 0,
                    max: 1,
                    opacity: 1,
                    vectors: {
                        show: false,
                        attr: 'newN',
                        scale: 500,
                        color: '#000000',
                        useTube: false,
                        radius: 20
                    }
                },
                {
                    url: "/data/arch/spanish-peak/result-forward-dikes.xyz",
                    show: false,
                    attr: '',
                    lut: 'Insar',
                    reverseLut: false,
                    min: 0,
                    max: 1,
                    opacity: 1,
                    vectors: {
                        show: false,
                        attr: 'n',
                        scale: 200,
                        color: '#FFFF00',
                        useTube: false,
                        radius: 20
                    }
                }
            ]

        const randColor = () => {
                const color = new THREE.Color( 0xffffff )
                color.setHex( Math.random() * 0xffffff )
                return '#'+color.getHexString()
                //return '#aaaaaa'
            }

        function ALL() {

            //console.log(mesh)

            function createSurfaceBorders(m, color) {

                // Build the HE-surface (aka, HalfEdge-surface)
                const vertices  = m.geometry.getAttribute('position')
                const triangles = m.geometry.index

                const borders = mesh.borders(vertices.array, triangles.array)

                const indices = []
                let id = 0
                for (let i=0; i<borders.length/6; ++i) {
                    indices.push(id++, id++)
                }

                const geometry = new THREE.BufferGeometry()
                geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(borders), 3))
                geometry.setIndex(indices)

                const material = new THREE.LineBasicMaterial({
                    linewidth: 1,
                    color: new THREE.Color(color?color:"#000000")
                })

                return new THREE.LineSegments(geometry, material)
            }

            let scene, camera, light, renderer, controls, cube, renderFct

            init()
            load()

            function init() {
                scene = new three.Scene

                camera = new three.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 100000 )
                camera.position.z = 100

                renderer = new three.WebGLRenderer({alpha: true})
                renderer.setPixelRatio( window.devicePixelRatio )
                renderer.setSize( window.innerWidth, window.innerHeight )
                document.body.appendChild( renderer.domElement )

                renderFct = new extra.RenderFunctions({renderer, scene, camera})

                window.addEventListener( 'resize', onWindowResize )

                controls = new extra.TrackballControls( camera, renderer.domElement )
                // controls.rotateSpeed = 1.0
                // controls.zoomSpeed = 1.2
                // controls.panSpeed = 0.8
                renderFct.add( controls.update )

                cube = new extra.installNavigationCube(
                    new extra.NavigationCubeParameters({
                        scene, 
                        camera, 
                        renderer,
                        controls, 
                        renderFunctions: renderFct, // will also add the cube in renderFct
                        labels: ['Right', 'Left', 'Up', 'Down', 'Front', 'Back'],

                        domElement : document.getElementById('orientCubeWrapper'),
                        domHome    : document.getElementById('goHome'), 
                        domSaveHome: document.getElementById('saveHome')
                    })
                )
            }

            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight
                camera.updateProjectionMatrix()
                renderer.setSize( window.innerWidth, window.innerHeight )
                controls.handleResize()
            }

            function animate() {
                renderFct.render()
                requestAnimationFrame( animate )
            }
            requestAnimationFrame( animate )

            function load() {
                const promises = []

                surfaceset.forEach( surface => {
                    if (surface.show===true) {
                        const promise = doSurface(surface)
                        if (promise) {
                            if (Array.isArray(promise)) promises.push(...promise)
                            else promises.push(promise)
                        }
                    }
                })

                if (pointsets) {
                    pointsets.forEach( pointset => {
                        //if (pointset.show===true) {
                            const promise = doPointset(pointset)
                            if (promise) {
                                if (Array.isArray(promise)) promises.push(...promise)
                                else promises.push(promise)
                            }
                        //}
                    })
                }

                if (plines) {
                    plines.forEach( pline => {
                        if (pline.show===true) {
                            const promise = doPLine(pline)
                            if (promise) {
                                if (Array.isArray(promise)) promises.push(...promise)
                                else promises.push(promise)
                            }
                        }
                    })
                }
                
                Promise.all(promises).then( _ => {
                    extra.changeBackground( {scene, color: '#888888'} )

                    function createGrayColor(intensity) {
                        if (intensity === 0) {
                            return '#000000'
                        }
                        const value = intensity * 0xFF | 0
                        const grayscale = (value << 16) | (value << 8) | value
                        const gray = grayscale.toString(16)
                        return gray.length===5 ? '#0' + gray : '#' + gray
                    }

                    const intensitySky    = 0.7 // param for flux
                    const intensityground = 0.1 // param for flux

                    const sky    = 0xffffff
                    const ground = createGrayColor(intensityground)
                    
                    const h1 = new THREE.HemisphereLight( sky, ground, intensitySky )
                    h1.position.set( 0, 10, 10 )
                    scene.add(h1)
                    
                    const h2 = new THREE.HemisphereLight( sky, ground, intensitySky )
                    h2.position.set( 0, -10, 0 )
                    scene.add(h2)
                    

                    const keyboard = new extra.Keyboard(document, 'keydown')
                    keyboard.setUpEvent(e => controls.constraint = extra.CONSTRAINT.NONE)

                    keyboard.addKey({key:'u', cb:e => extra.changeView('up', {scene, camera, controls}) })
                    keyboard.addKey({key:'d', cb:e => extra.changeView('down', {scene, camera, controls}) })
                    keyboard.addKey({key:'s', cb:e => extra.changeView('south', {scene, camera, controls}) })
                    keyboard.addKey({key:'n', cb:e => extra.changeView('north', {scene, camera, controls}) })
                    keyboard.addKey({key:'e', cb:e => extra.changeView('east', {scene, camera, controls}) })
                    keyboard.addKey({key:'w', cb:e => extra.changeView('west', {scene, camera, controls}) })

                    keyboard.addKey({key:' ', cb:e => cube.restoreView() })
                    keyboard.addKey({key:'f', cb:e => extra.zoomToModel({scene, camera, controls, duration:300}) })

                    keyboard.addKey({key:'x', cb:e => controls.constraint = extra.CONSTRAINT.X})
                    keyboard.addKey({key:'y', cb:e => controls.constraint = extra.CONSTRAINT.Y})
                    keyboard.addKey({key:'z', cb:e => controls.constraint = extra.CONSTRAINT.Z})

                    renderer.domElement.addEventListener('dblclick', event => {
                        extra.zoomToIntersection( {scene, event, camera, controls} )
                    })

                    const LOADER = document.getElementById('js-loader');
                    LOADER.remove();
                })
                .then( () => {
                    extra.changeView('up', {scene, camera, controls})
                })
            }

            function doSurface(surfaceInfo) {
                if (Array.isArray(surfaceInfo.url)) {
                    const promises = []
                    surfaceInfo.url.forEach( url => {
                        const promise = doOneSurface(url)
                        if (promise) promises.push(promise)
                    })
                    return promises
                }
                else {
                    return doOneSurface(surfaceInfo.url)
                }

                function doOneSurface(url) {
                    const promise = fetch(url)
                        .then( res => {
                            if ( res.ok ) return res.text()
                            return undefined
                        })
                        .then( buffer => {
                            //console.log( kepler.generateColorMap('Insar', 32, 3) )

                            if (! buffer) return undefined

                            const scolor = randColor()

                            const dfs = io.decodeGocadTS(buffer, {shared: false, merge: true})
                            dfs.forEach( df => {
                                let skin

                                let position = df.series['positions']
                                //position = math.add([ position, math.mult(df.series['U'], 500) ])

                                console.log('min-max position surface:', math.minMax(position) )

                                if (surfaceInfo.translation) {
                                    const x = surfaceInfo.translation[0]
                                    const y = surfaceInfo.translation[1]
                                    const z = surfaceInfo.translation[2]
                                    position = position.map( v => [v[0]+x, v[1]+y, v[2]+z])
                                }

                                const manager = new dataframe.Manager(df, [
                                    new math.PositionDecomposer,       // x y z
                                    new math.ComponentDecomposer,      // Ux Uy Uz Sxx Sxy Sz Syy Syz Szz
                                    new math.AreaDecomposer,           // aire
                                    new math.VectorNormDecomposer,     // U
                                    new math.EigenValuesDecomposer,    // S1 S2 S3
                                    new math.EigenVectorsDecomposer    // S1 S2 S3
                                ])

                                // console.log('available scalar attributes:', manager.names(1) )
                                // console.log('available vector attributes:', manager.names(3) )

                                if (0) {
                                    console.log('x:', math.minMaxArray(manager.serie(1, 'x').array))
                                    console.log('y:', math.minMaxArray(manager.serie(1, 'y').array))
                                    console.log('z:', math.minMaxArray(manager.serie(1, 'z').array))
                                }

                                let attr = undefined 
                                if (surfaceInfo.attr) attr = manager.serie(1, surfaceInfo.attr)
                                if (attr) {
                                    console.log('attribute', surfaceInfo.attr, math.minMaxArray(attr.array))
                                }

                                if (surfaceInfo.wireframe && surfaceInfo.wireframe.show) {
                                    scene.add( kepler.createSurface({
                                        positions: position,
                                        indices  : df.series['indices'],
                                        parameters: new kepler.SurfaceParameters({
                                            wireframe: true, 
                                            color: surfaceInfo.wireframe.color,
                                            opacity: 1.0
                                        })
                                    }) )
                                }
                                
                                // surface
                                const surface = kepler.createSurface({
                                    positions: position,
                                    indices  : df.series['indices'],
                                    parameters: new kepler.SurfaceParameters({
                                        flat: surfaceInfo.surface.flat, 
                                        wireframe: false, 
                                        color: surfaceInfo.surface.color!==undefined ? surfaceInfo.surface.color : scolor,
                                        opacity: surfaceInfo.surface.opacity,
                                        creaseAngle: surfaceInfo.surface.creaseAngle
                                    })
                                })

                                if (surfaceInfo.surface.show) {
                                    scene.add(surface)
                                    if (attr) {
                                        kepler.paintAttribute( surface, attr, new kepler.PaintParameters({
                                            atVertex: true,
                                            lut: surfaceInfo.lut,
                                            duplicateLut: surfaceInfo.duplicateLut,
                                            reverseLut: surfaceInfo.reverseLut
                                        }) )
                                    }
                                }

                                // if ( (surfaceInfo.iso && (surfaceInfo.iso.show===false || attr===undefined)) ) {
                                //     scene.add(surface)
                                //     if (attr) {
                                //         kepler.paintAttribute( surface, attr, new kepler.PaintParameters({
                                //             atVertex: true,
                                //             lut: surfaceInfo.lut,
                                //             duplicateLut: surfaceInfo.iso.duplicateLut,
                                //             reverseLut: surfaceInfo.reverseLut
                                //         }) )
                                //     }
                                // }
                                
                                if (surfaceInfo.borders && surfaceInfo.borders.show) {
                                    const borders = createSurfaceBorders(surface, surfaceInfo.borders.color)
                                    scene.add( borders )
                                }

                                if (surfaceInfo.vectors !== undefined && surfaceInfo.vectors.show === true) {
                                    const vattr = manager.serie(3, surfaceInfo.vectors.attr)
                                    if (vattr) {
                                        if (surfaceInfo.vectors.useTube) {
                                            scene.add( kepler.createTubeVectors({
                                                geometry: surface.geometry,
                                                vectorField: vattr,
                                                parameters: new kepler.TubeVectorsParameters({
                                                    scale: surfaceInfo.vectors.scale,
                                                    color: surfaceInfo.vectors.color,
                                                    radius: surfaceInfo.vectors.radius
                                                })
                                            }) )
                                        }
                                        else {
                                            scene.add( kepler.createVectors({
                                                geometry: surface.geometry,
                                                vectorField: vattr,
                                                parameters: new kepler.TubeVectorsParameters({
                                                    scale: surfaceInfo.vectors.scale,
                                                    color: surfaceInfo.vectors.color
                                                })
                                            }) )
                                        }
                                    }
                                }

                                if (surfaceInfo.failure !== undefined && surfaceInfo.failure.show === true) {
                                    if (df.series[surfaceInfo.failure.stress] !== undefined) {
                                        scene.add( kepler.createFailurePlanes({
                                            geometry: surface.geometry,
                                            dataframe: df,
                                            parameters: new kepler.FailurePlanesParameters({
                                                stress: surfaceInfo.failure.stress,
                                                size: surfaceInfo.failure.size,
                                                sizeAttribute: surfaceInfo.failure.sizeAttribute?surfaceInfo.failure.sizeAttribute:'',
                                                paintAttribute: surfaceInfo.failure.paintAttribute?surfaceInfo.failure.paintAttribute:'',
                                                color: surfaceInfo.failure.color,
                                                circle: surfaceInfo.failure.circle,
                                                borders: surfaceInfo.failure.borders,
                                                type: surfaceInfo.failure.type
                                            })
                                        }) )
                                    }
                                }

                                if (attr && surfaceInfo.iso) {
                                    const minmax = dataframe.array.minMax(attr.array)
                                    //let isos = kepler.generateIsos(minmax[0], minmax[1], 20)
                                    //isos = [-0.2, 0, 0.2]
                                    // let isos = kepler.generateIsos(minmax[0], minmax[1], surfaceInfo.iso.nb)
                                    //let isos = kepler.generateIsosBySpacing(minmax[0], minmax[1], surfaceInfo.iso.spacing)
                                    let iso = undefined
                                    if (surfaceInfo.iso.useMinMax!=undefined && surfaceInfo.iso.useMinMax===true) {
                                        if (surfaceInfo.iso.spacing) {
                                            isos = kepler.generateIsosBySpacing(surfaceInfo.iso.min, surfaceInfo.iso.max, surfaceInfo.iso.spacing)
                                        }
                                        else {
                                            isos = kepler.generateIsos(surfaceInfo.iso.min, surfaceInfo.iso.max, surfaceInfo.iso.nb)
                                        }
                                    }
                                    else {
                                        if (surfaceInfo.iso.spacing) {
                                            isos = kepler.generateIsosBySpacing(minmax[0], minmax[1], surfaceInfo.iso.spacing)
                                        }
                                        else {
                                            isos = kepler.generateIsos(minmax[0], minmax[1], surfaceInfo.iso.nb)
                                        }
                                    }
                                    

                                    if (surfaceInfo.iso.show) {
                                        const iso = kepler.createIsoContours(
                                            surface,
                                            attr, {
                                                parameters: new kepler.IsoContoursParameters({
                                                    color: '#ffffff',
                                                    lineColor: '#000000',
                                                    isoList: isos,
                                                    filled: surfaceInfo.iso.showFill,
                                                    lined: surfaceInfo.iso.showLines,
                                                    opacity: surfaceInfo.iso.opacity,
                                                    lut: surfaceInfo.lut,
                                                    reverseLut: surfaceInfo.reverseLut,
                                                    duplicateLut: surfaceInfo.duplicateLut,
                                                    min: surfaceInfo.iso.min,
                                                    max: surfaceInfo.iso.max
                                                })
                                            }
                                        )
                                        scene.add( iso )
                                        // const cb = new kepler.Colorbar({
                                        //     lutName: surfaceInfo.lut,
                                        //     min: minmax[0],
                                        //     max: minmax[1]
                                        // })
                                        // renderFct.add(cb.render)
                                    }
                                }
                            })
                        })
                    return promise
                }
            }

            function doPointset(psetInfo) {
                if (Array.isArray(psetInfo.url)) {
                    const promises = []
                    psetInfo.url.forEach( url => {
                        const promise = doOnePset(url)
                        if (promise) promises.push(promise)
                    })
                    return promises
                }
                else {
                    return doOnePset(psetInfo.url)
                }

                function doOnePset(url) {
                    const promise = fetch(url)
                        .then( res => {
                            if ( res.ok ) return res.text()
                            return undefined
                        })
                        .then( buffer => {
                            if (! buffer) return undefined

                            const scolor = randColor()

                            const dfs = io.decodeXYZ(buffer, {shared: false, merge: true})
                            dfs.forEach( df => {
                                let skin

                                let position = df.series['positions']
                                console.log('min-max position pointset:', math.minMax(position) )

                                const manager = new dataframe.Manager(df, [
                                    new math.PositionDecomposer,
                                    new math.ComponentDecomposer,
                                    new math.VectorNormDecomposer,
                                    new math.EigenValuesDecomposer
                                ])

                                // console.log('available scalar attributes:', manager.names(1) )
                                // console.log('available vector attributes:', manager.names(3) )

                                let attr = manager.serie(1, psetInfo.attr)
                                const SKIN = kepler.createPointset({
                                    position: position,
                                    parameters: new kepler.PointsetParameters({
                                        size: psetInfo.size,
                                        color: psetInfo.color!==undefined?psetInfo.color:undefined
                                    })
                                })

                                if (psetInfo.show) {
                                    scene.add( SKIN )
                                }

                                if (psetInfo.attr !== undefined && attr && psetInfo.show === true) {
                                    kepler.paintAttribute( SKIN, attr, new kepler.PaintParameters({
                                        atVertex: true,
                                        lut: psetInfo.lut,
                                        duplicateLut: psetInfo.duplicateLut,
                                        reverseLut: psetInfo.reverseLut
                                    }) )
                                }
                                
                                if (psetInfo.vectors !== undefined && psetInfo.vectors.show === true) {
                                    const vattr = manager.serie(3, psetInfo.vectors.attr)
                                    if (vattr) {
                                        if (psetInfo.vectors.useTube) {
                                            scene.add( kepler.createTubeVectors({
                                                geometry: SKIN.geometry,
                                                vectorField: vattr,
                                                parameters: new kepler.TubeVectorsParameters({
                                                    scale: psetInfo.vectors.scale,
                                                    color: psetInfo.vectors.color,
                                                    radius: psetInfo.vectors.radius
                                                })
                                            }) )
                                        }
                                        else {
                                            scene.add( kepler.createVectors({
                                                geometry: SKIN.geometry,
                                                vectorField: vattr,
                                                parameters: new kepler.TubeVectorsParameters({
                                                    scale: psetInfo.vectors.scale,
                                                    color: psetInfo.vectors.color
                                                })
                                            }) )
                                        }
                                    }
                                }

                            })
                        })
                    return promise
                }
            }

            function doPLine(plineInfo) {
                if (Array.isArray(plineInfo.url)) {
                    const promises = []
                    plineInfo.url.forEach( url => {
                        const promise = doOnePline(url)
                        if (promise) promises.push(promise)
                    })
                    return promises
                }
                else {
                    return doOnePline(plineInfo.url)
                }

                function doOnePline(url) {
                    const promise = fetch(url)
                        .then( res => {
                            if ( res.ok ) return res.text()
                            return undefined
                        })
                        .then( buffer => {
                            if (! buffer) return undefined

                            const scolor = randColor()

                            const dfs = io.decodeGocadPL(buffer, {shared: false, merge: true})

                            dfs.forEach( df => {

                                if (plineInfo.show) {

                                    let position = df.series['positions']
                                    console.log('min-max position pointset:', math.minMax(position) )

                                    const skin = kepler.createLineset({
                                        position: df.series['positions'],
                                        parameters: {
                                            useTube: plineInfo.useTube,
                                            tubeRadius: plineInfo.tubeRadius
                                        }
                                    })
                                    scene.add( skin )
                                }
                            })
                        })
                    return promise
                }
            }
    }

    </script>
</body>
</html>