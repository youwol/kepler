<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Testing Kepler</title>
    <script src='/projects/youwol/workspace/packages/dataframe/dist/@youwol/dataframe.js'></script>
    <script src='/projects/youwol/workspace/packages/math/dist/@youwol/math.js'></script>
    <script src='/projects/youwol/workspace/packages/attribute/dist/@youwol/attribute.js'></script>
    <script src='/projects/youwol/workspace/packages/io/dist/@youwol/io.js'></script>

    <script src='/projects/youwol/workspace/packages/three-extra/node_modules/three/build/three.min.js'></script>
    <script src='/projects/youwol/workspace/packages/three-extra/dist/@youwol/three-extra.js'></script>
    <script src='/projects/youwol/workspace/packages/kepler/dist/@youwol/kepler.js'></script>
    
    <script src="https://kit.fontawesome.com/daa834e337.js" crossorigin="anonymous"></script>

    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="loading" id="js-loader">
        <div class="loader"></div>
    </div>

    <div class='home-container'>
        <span>
            <div class='buttonIcon'>
                <div id='goHome'><i class='fa fa-home'></i></div>
            </div>
            <div class='buttonIcon'>
                <div id='saveHome'><i class='fa fa-clinic-medical'></i></div>
            </div>
            <div class='right-container'>
                <div id='orientCubeWrapper'></div>
            </div>
        </span>
    </div>

    <script>
        const three     = globalThis['THREE']
        
        const dataframe = globalThis['@youwol/dataframe']
        const math      = globalThis['@youwol/math']
        const attribute = globalThis['@youwol/attribute']

        const io        = globalThis['@youwol/io']

        const extra     = globalThis['@youwol/three-extra']
        const kepler    = globalThis['@youwol/kepler']
        

        const surfaceset = [
            {
                //url: "/platform/test/geophysics/arche/model_test_sphere/sphere_5120.ts",
                //url: '/platform/test/files/gocad/ts/S1_properties.ts',
                //url: "/platform/test/models/arche/Santos/out/horizon.ts",
                //url: "/platform/test/files/gocad/ts/output.ts",
                url: "/platform/test/geophysics/arche/lolo2020-petronas/results_salt_smoothed_intersected_edited_positive.ts",

                //url: "/platform/test/models/arche/test-HS/result_grid_arche_half_space_-50m.ts",
                //url: "/platform/test/models/arche/test-HS/result_grid_poly3d_half_space_0m.ts",
                //url: "/platform/test/models/arche/test-HS/result_S1_arche_0m.ts",
                show: true,
                attr: 'U',
                lut: 'Insar',
                min: 0,
                max: 1,
                isoFill: {
                    opacity: 1,
                    show: true,
                    showLines: true,
                    lut: 'Spectrum',
                    nb : 20,
                    min: -1e7,
                    max: 1e7,
                    reversedLut: false
                },
                wireframe: {
                    show: false,
                    color: '#000000'
                }
            }
        ]

        let scene, camera, light, renderer, controls, cube, renderFct

        init()
        load()

        function init() {
            scene = new three.Scene

            camera = new three.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 100000 )
            camera.position.z = 100

            renderer = new three.WebGLRenderer({alpha: true})
            renderer.setPixelRatio( window.devicePixelRatio )
            renderer.setSize( window.innerWidth, window.innerHeight )
            document.body.appendChild( renderer.domElement )

            renderFct = new extra.RenderFunctions({renderer, scene, camera})

            window.addEventListener( 'resize', onWindowResize )

            controls = new extra.TrackballControls( camera, renderer.domElement )
            // controls.rotateSpeed = 1.0
            // controls.zoomSpeed = 1.2
            // controls.panSpeed = 0.8
            renderFct.add( controls.update )

            const cube = new extra.installNavigationCube(
                new extra.NavigationCubeParameters({
                    scene, 
                    camera, 
                    renderer,
                    controls, 
                    renderFunctions: renderFct, // will also add the cube in renderFct
                    //labels: ['East', 'West', 'Up', 'Down', 'South', 'North'],

                    domElement : document.getElementById('orientCubeWrapper'),
                    domHome    : document.getElementById('goHome'), 
                    domSaveHome: document.getElementById('saveHome')
                })
            )
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight
            camera.updateProjectionMatrix()
            renderer.setSize( window.innerWidth, window.innerHeight )
            controls.handleResize()
        }

        function animate() {
            renderFct.render()
            requestAnimationFrame( animate )
        }
        requestAnimationFrame( animate )

        function load() {
            const promises = []

            surfaceset.forEach( surface => {
                if (surface.show===true) {
                    const promise = doSurface(surface)
                    if (promise) {
                        promises.push(promise)
                    }
                }
            })
            
            Promise.all(promises).then( _ => {
                extra.changeBackground( {scene, color: '#888888'} )

                scene.add( extra.createDefaultLights({object: scene, scaling: 10, intensity: 1}) )

                const keyboard = new extra.Keyboard(document, 'keydown')
                keyboard.setUpEvent(e => controls.constraint = extra.CONSTRAINT.NONE)

                keyboard.addKey({key:'u', cb:e => extra.changeView('up', {scene, camera, controls}) })
                keyboard.addKey({key:'d', cb:e => extra.changeView('down', {scene, camera, controls}) })
                keyboard.addKey({key:'s', cb:e => extra.changeView('south', {scene, camera, controls}) })
                keyboard.addKey({key:'n', cb:e => extra.changeView('north', {scene, camera, controls}) })
                keyboard.addKey({key:'e', cb:e => extra.changeView('east', {scene, camera, controls}) })
                keyboard.addKey({key:'w', cb:e => extra.changeView('west', {scene, camera, controls}) })
                keyboard.addKey({key:'f', cb:e => extra.zoomToModel({scene, camera, controls, duration:300}) })

                keyboard.addKey({key:'x', cb:e => controls.constraint = extra.CONSTRAINT.X})
                keyboard.addKey({key:'y', cb:e => controls.constraint = extra.CONSTRAINT.Y})
                keyboard.addKey({key:'z', cb:e => controls.constraint = extra.CONSTRAINT.Z})

                renderer.domElement.addEventListener('dblclick', event => {
                    extra.zoomToIntersection( {scene, event, camera, controls} )
                })

                const LOADER = document.getElementById('js-loader');
                LOADER.remove();
            })
            .then( () => {
                extra.changeView('up', {scene, camera, controls})
            })
        }

        function doSurface(surfaceInfo) {
            const promise = fetch(surfaceInfo.url)
                .then( res => {
                    if ( res.ok ) return res.text()
                    return undefined
                })
                .then( buffer => {
                    if (! buffer) return undefined
                    const dfs = io.decodeGocadTS(buffer, {shared: true, merge: false})
                    dfs.forEach( df => {
                        let skin

                        let position = df.series['positions']
                        //position = math.add([ position, math.mult(df.series['U'], 500) ])

                        const manager = new attribute.AttributeManager(df, [
                            new attribute.PositionDecomposer,
                            new attribute.ComponentDecomposer,
                            new attribute.AreaDecomposer,
                            new attribute.VectorNormDecomposer
                        ])

                        console.log('available scalar attributes:', manager.names(1) )
                        console.log('available vector attributes:', manager.names(3) )

                        const attr = manager.serie(1, surfaceInfo.attr)
                        if (attr) console.log(math.minMaxArray(attr.array))

                        if (surfaceInfo.wireframe.show) {
                            scene.add( kepler.createSurface({
                                positions: position,
                                indices  : df.series['indices'],
                                parameters: new kepler.SurfaceParameters({
                                    wireframe: true, 
                                    color: surfaceInfo.wireframe.color,
                                    opacity: 1.0
                                })
                            }) )
                        }
                        
                        // surface
                        const surface = kepler.createSurface({
                            positions: position,
                            indices  : df.series['indices'],
                            parameters: new kepler.SurfaceParameters({
                                flat: false, 
                                wireframe: false, 
                                color: '#aaaaaa',
                                opacity: 1.0,
                                creaseAngle: 0
                            })
                        })
                        if (surfaceInfo.isoFill.show===false) {
                            scene.add(surface)
                            if (attr) {
                                kepler.paintAttribute( surface, attr, new kepler.PaintParameters({
                                    atVertex: true,
                                    lut: surfaceInfo.isoFill.lut
                                }) )
                            }
                        }

                        // BBox
                        scene.add( kepler.createBBox(surface) )

                        if (attr) {
                            const minmax = dataframe.array.minMax(attr.array)
                            //let isos = kepler.generateIsos(minmax[0], minmax[1], 20)
                            //isos = [-0.2, 0, 0.2]
                            let isos = kepler.generateIsos(minmax[0], minmax[1], surfaceInfo.isoFill.nb)

                            if (surfaceInfo.isoFill.show) {
                                scene.add( kepler.createIsoContours(
                                    surface,
                                    attr, {
                                        parameters: new kepler.IsoContoursParameters({
                                            color: '#ffffff',
                                            isoList: isos,
                                            filled: true,
                                            opacity: surfaceInfo.isoFill.opacity,
                                            lut: surfaceInfo.isoFill.lut,
                                            min: surfaceInfo.isoFill.min,
                                            max: surfaceInfo.isoFill.max
                                        })
                                    }
                                ) )
                            }
                            if (surfaceInfo.isoFill.showLines) {
                                scene.add( kepler.createIsoContours(
                                    surface,
                                    attr, {
                                        parameters: new kepler.IsoContoursParameters({
                                            color: '#000000',
                                            isoList: isos,
                                            filled: false,
                                            lut: surfaceInfo.isoFill.lut,
                                            min: surfaceInfo.isoFill.min,
                                            max: surfaceInfo.isoFill.max
                                        })
                                    })
                                )
                            }
                        }
                    })
                })
            return promise
        }

    </script>
</body>
</html>