<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Testing Kepler</title>
    <script src='/devs/workspace/packages/dataframe/dist/@youwol/dataframe.js'></script>
    <script src='/devs/workspace/packages/math/dist/@youwol/math.js'></script>
    <script src='/devs/workspace/packages/geometry/dist/@youwol/geometry.js'></script>
    <script src='/devs/workspace/packages/attribute/dist/@youwol/attribute.js'></script>
    <script src='/devs/workspace/packages/io/dist/@youwol/io.js'></script>
    <script src='/devs/workspace/packages/mesh.js'></script>

    <script src='/devs/workspace/packages/three-extra/node_modules/three/build/three.min.js'></script>
    <script src='/devs/workspace/packages/three-extra/dist/@youwol/three-extra.js'></script>
    <script src='/devs/workspace/packages/kepler/dist/@youwol/kepler.js'></script>
    
    <script src="https://kit.fontawesome.com/daa834e337.js" crossorigin="anonymous"></script>

    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="loading" id="js-loader">
        <div class="loader"></div>
    </div>

    <div class='home-container'>
        <span>
            <div class='buttonIcon'>
                <div id='goHome'><i class='fa fa-home'></i></div>
            </div>
            <div class='buttonIcon'>
                <div id='saveHome'><i class='fa fa-clinic-medical'></i></div>
            </div>
            <div class='right-container'>
                <div id='orientCubeWrapper'></div>
            </div>
        </span>
    </div>

    <script>
        const three     = globalThis['THREE']
        
        const dataframe = globalThis['@youwol/dataframe']
        const math      = globalThis['@youwol/math']
        const geometry  = globalThis['@youwol/geometry']
        const attribute = globalThis['@youwol/attribute']

        const io        = globalThis['@youwol/io']

        const extra     = globalThis['@youwol/three-extra']
        const kepler    = globalThis['@youwol/kepler']
        let mesh      = undefined 
        
        globalThis['MeshModule']().then( m => {
            mesh = m
        }).then( _ => {
            //console.log(mesh)
            ALL() ;
        })

        const surfaceset = [
                {
                    // url: "/data/arch/mud/simulations-grid.ts",
                    url: "/data/arch/sphere/simulations-grids.ts",
                    // url: [
                    //     "/test/models/KemOne/surfaces/00-Plio-Quaternaire.ts",	
                    //     "/test/models/KemOne/surfaces/03-Aquitanien-Moy.ts",	
                    //     "/test/models/KemOne/surfaces/06-Marnes-Top.ts",	
                    //     "/test/models/KemOne/surfaces/09-Infra-Sel.ts", 
                    //     "/test/models/KemOne/surfaces/faults.ts", 
                    //     "/test/models/KemOne/surfaces/01-Miocene.ts", 
                    //     "/test/models/KemOne/surfaces/04-Aquitanien-Inf.ts", 
                    //     "/test/models/KemOne/surfaces/07-Marnes-Mid.ts", 
                    //     "/test/models/KemOne/surfaces/10-Serie-Rouge.ts", 
                    //     "/test/models/KemOne/surfaces/02-Aquitanien-Sup.ts",	
                    //     "/test/models/KemOne/surfaces/05-Sel-Sup.ts", 
                    //     "/test/models/KemOne/surfaces/08-Marnes-Base.ts",	
                    //     "/test/models/KemOne/surfaces/11-Serie-Grise.ts",
                    //     "/test/models/KemOne/3D_model/00-Plio-Quaternaire.ts",
                    //     "/test/models/KemOne/3D_model/03-Aquitanien-Moy.ts",	
                    //     "/test/models/KemOne/3D_model/06-Marnes-Top.ts",	
                    //     "/test/models/KemOne/3D_model/09-Infra-Sel.ts", 
                    //     "/test/models/KemOne/3D_model/faults.ts", 
                    //     "/test/models/KemOne/3D_model/01-Miocene.ts", 
                    //     "/test/models/KemOne/3D_model/04-Aquitanien-Inf.ts", 
                    //     "/test/models/KemOne/3D_model/07-Marnes-Mid.ts", 
                    //     "/test/models/KemOne/3D_model/10-Serie-Rouge.ts", 
                    //     "/test/models/KemOne/3D_model/02-Aquitanien-Sup.ts",	
                    //     "/test/models/KemOne/3D_model/05-Sel-Sup.ts", 
                    //     "/test/models/KemOne/3D_model/08-Marnes-Base.ts",	
                    //     "/test/models/KemOne/3D_model/11-Serie-Grise.ts",
                    // ],
                    show: true,
                    attr: 'Syz',
                    lut: 'Insar',
                    min: 0,
                    max: 1,
                    opacity: 1,
                    flat: false,
                    borders: {
                        show: true,
                        color: "#000000"
                    },
                    wireframe: {
                        show: false,
                        color: '#000000'
                    },
                    iso: {
                        opacity: 1,
                        show: true,
                        showFill: true,
                        showLines: true,
                        duplicateLut: 1,
                        nb :   40,
                        spacing: 0.02,
                        // min: -1e10,
                        // max:  1e10,
                        min: -0.28,
                        max:  0.28,
                        reversedLut: false
                    },
                    vectors: {
                        show: false,
                        attr: 'dikes',
                        scale: .03
                    }
                },
                // --------------------------------------------------------------------
                {
                    // url: "/data/arch/mud/simulations-Mud_Volcano_top_9421.ts",
                    url: "/data/arch/sphere/sphere_5120.ts",
                    // url: [
                    //     "/test/models/KemOne/wells_caverns_derricks/derrick_01.ts", 
                    //     "/test/models/KemOne/wells_caverns_derricks/derrick_02.ts", 
                    //     "/test/models/KemOne/wells_caverns_derricks/salt_cavern_01_small.ts", 
                    //     "/test/models/KemOne/wells_caverns_derricks/salt_cavern_02_small.ts", 
                    //     "/test/models/KemOne/wells_caverns_derricks/well_01_small.ts", 
                    //     //"/test/models/KemOne/wells_caverns_derricks/well_02_small.ts"
                    // ],
                    show: true,
                    attr: 'z',
                    lut: 'Insar',
                    min: 0,
                    max: 1,
                    opacity: 1,
                    flat: true,
                    borders: {
                        show: false,
                        color: "#000000"
                    },
                    wireframe: {
                        show: false,
                        color: '#000000'
                    },
                    iso: {
                        opacity: 1,
                        show: true,
                        showFill: true,
                        showLines: false,
                        creaseAngle: 0,
                        duplicateLut: 1,
                        nb :   10,
                        spacing: 0.01,
                        min: -1e7,
                        max:  1e7,
                        reversedLut: false
                    },
                    vectors: {
                        show: true,
                        attr: 'iDikes',
                        scale: .03
                    }
                }
            ]

        const randColor = () => {
                const color = new THREE.Color( 0xffffff )
                color.setHex( Math.random() * 0xffffff )
                console.log('=========>', '#'+color.getHexString())
                return '#'+color.getHexString()
                //return '#aaaaaa'
            }

        function ALL() {

            //console.log(mesh)

            function createSurfaceBorders(m, color) {

                // Build the HE-surface (aka, HalfEdge-surface)
                const vertices  = m.geometry.getAttribute('position')
                const triangles = m.geometry.index

                const surface = new mesh.Mesh(vertices.array, triangles.array)
                // console.log('verts ', surface.nVertices())
                // console.log('faces ', surface.nFaces())
                // console.log('edges ', surface.nEdges())
                // console.log('hedges', surface.nHalfedges())
                // console.log('bounds', surface.nBoundaries())
                const borders = surface.borders()
                // console.log('Border', borders.length)
                // console.log('Border', borders)

                const indices = []
                let id = 0
                for (let i=0; i<borders.length/6; ++i) {
                    indices.push(id++, id++)
                }

                const geometry = new THREE.BufferGeometry()
                geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(borders), 3))
                geometry.setIndex(indices)

                const material = new THREE.LineBasicMaterial({
                    linewidth: 1,
                    color: new THREE.Color(color?color:"#000000")
                })

                return new THREE.LineSegments(geometry, material)
            }

            let scene, camera, light, renderer, controls, cube, renderFct

            init()
            load()

            function init() {
                scene = new three.Scene

                camera = new three.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 100000 )
                camera.position.z = 100

                renderer = new three.WebGLRenderer({alpha: true})
                renderer.setPixelRatio( window.devicePixelRatio )
                renderer.setSize( window.innerWidth, window.innerHeight )
                document.body.appendChild( renderer.domElement )

                renderFct = new extra.RenderFunctions({renderer, scene, camera})

                window.addEventListener( 'resize', onWindowResize )

                controls = new extra.TrackballControls( camera, renderer.domElement )
                // controls.rotateSpeed = 1.0
                // controls.zoomSpeed = 1.2
                // controls.panSpeed = 0.8
                renderFct.add( controls.update )

                const cube = new extra.installNavigationCube(
                    new extra.NavigationCubeParameters({
                        scene, 
                        camera, 
                        renderer,
                        controls, 
                        renderFunctions: renderFct, // will also add the cube in renderFct
                        labels: ['Right', 'Left', 'Up', 'Down', 'Front', 'Back'],

                        domElement : document.getElementById('orientCubeWrapper'),
                        domHome    : document.getElementById('goHome'), 
                        domSaveHome: document.getElementById('saveHome')
                    })
                )
            }

            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight
                camera.updateProjectionMatrix()
                renderer.setSize( window.innerWidth, window.innerHeight )
                controls.handleResize()
            }

            function animate() {
                renderFct.render()
                requestAnimationFrame( animate )
            }
            requestAnimationFrame( animate )

            function load() {
                const promises = []

                surfaceset.forEach( surface => {
                    if (surface.show===true) {
                        const promise = doSurface(surface)
                        if (promise) {
                            if (Array.isArray(promise)) promises.push(...promise)
                            else promises.push(promise)
                        }
                    }
                })
                
                Promise.all(promises).then( _ => {
                    extra.changeBackground( {scene, color: '#888888'} )

                    //scene.add( extra.createDefaultLights({object: scene, scaling: 10, intensity: 1}) )

                    const hemiLight = new THREE.HemisphereLight( 0xffffff, 0x444444 );
				    hemiLight.position.set( 0, 2, 0 );
				    scene.add( hemiLight );

                    const keyboard = new extra.Keyboard(document, 'keydown')
                    keyboard.setUpEvent(e => controls.constraint = extra.CONSTRAINT.NONE)

                    keyboard.addKey({key:'u', cb:e => extra.changeView('up', {scene, camera, controls}) })
                    keyboard.addKey({key:'d', cb:e => extra.changeView('down', {scene, camera, controls}) })
                    keyboard.addKey({key:'s', cb:e => extra.changeView('south', {scene, camera, controls}) })
                    keyboard.addKey({key:'n', cb:e => extra.changeView('north', {scene, camera, controls}) })
                    keyboard.addKey({key:'e', cb:e => extra.changeView('east', {scene, camera, controls}) })
                    keyboard.addKey({key:'w', cb:e => extra.changeView('west', {scene, camera, controls}) })
                    keyboard.addKey({key:'f', cb:e => extra.zoomToModel({scene, camera, controls, duration:300}) })

                    keyboard.addKey({key:'x', cb:e => controls.constraint = extra.CONSTRAINT.X})
                    keyboard.addKey({key:'y', cb:e => controls.constraint = extra.CONSTRAINT.Y})
                    keyboard.addKey({key:'z', cb:e => controls.constraint = extra.CONSTRAINT.Z})

                    renderer.domElement.addEventListener('dblclick', event => {
                        extra.zoomToIntersection( {scene, event, camera, controls} )
                    })

                    const LOADER = document.getElementById('js-loader');
                    LOADER.remove();
                })
                .then( () => {
                    extra.changeView('up', {scene, camera, controls})
                })
            }

            function doSurface(surfaceInfo) {
                if (Array.isArray(surfaceInfo.url)) {
                    const promises = []
                    surfaceInfo.url.forEach( url => {
                        //console.log("fetching", url)
                        const promise = doOneSurface(url)
                        if (promise) promises.push(promise)
                    })
                    return promises
                }
                else {
                    //console.log("fetching", surfaceInfo.url)
                    return doOneSurface(surfaceInfo.url)
                }

                function doOneSurface(url) {
                    const promise = fetch(url)
                        .then( res => {
                            if ( res.ok ) return res.text()
                            return undefined
                        })
                        .then( buffer => {
                            //console.log( kepler.generateColorMap('Insar', 32, 3) )

                            if (! buffer) return undefined

                            const scolor = randColor()

                            const dfs = io.decodeGocadTS(buffer, {shared: false, merge: false})
                            dfs.forEach( df => {
                                let skin

                                let position = df.series['positions']
                                //position = math.add([ position, math.mult(df.series['U'], 500) ])

                                const manager = new attribute.AttributeManager(df, [
                                    new attribute.PositionDecomposer,
                                    new attribute.ComponentDecomposer,
                                    new attribute.AreaDecomposer,
                                    new attribute.VectorNormDecomposer,
                                    new attribute.EigenValuesDecomposer
                                ])

                                console.log('available scalar attributes:', manager.names(1) )
                                console.log('available vector attributes:', manager.names(3) )

                                {
                                    console.log('x:', math.minMaxArray(manager.serie(1, 'x').array))
                                    console.log('y:', math.minMaxArray(manager.serie(1, 'y').array))
                                    console.log('z:', math.minMaxArray(manager.serie(1, 'z').array))
                                }

                                let attr = manager.serie(1, surfaceInfo.attr)
                                if (attr) {
                                    console.log('attribute', surfaceInfo.attr, math.minMaxArray(attr.array))

                                    // const f = new attribute.Fringes(surfaceInfo.attr, 0.1)
                                    // attr = f.serie(df, 1, surfaceInfo.attr)
                                }

                                if (surfaceInfo.wireframe.show) {
                                    scene.add( kepler.createSurface({
                                        positions: position,
                                        indices  : df.series['indices'],
                                        parameters: new kepler.SurfaceParameters({
                                            wireframe: true, 
                                            color: surfaceInfo.wireframe.color,
                                            opacity: 1.0
                                        })
                                    }) )
                                }
                                
                                //const randColor = () => "#" + Math.floor(Math.random()*16777215).toString(16)
                                
                                // surface
                                const surface = kepler.createSurface({
                                    positions: position,
                                    indices  : df.series['indices'],
                                    parameters: new kepler.SurfaceParameters({
                                        flat: surfaceInfo.flat, 
                                        wireframe: false, 
                                        color: scolor,
                                        opacity: surfaceInfo.opacity,
                                        creaseAngle: 0 // degrees !!!
                                    })
                                })
                                if (surfaceInfo.iso.show===false) {
                                    scene.add(surface)
                                    if (attr) {
                                        kepler.paintAttribute( surface, attr, new kepler.PaintParameters({
                                            atVertex: true,
                                            lut: surfaceInfo.lut,
                                            duplicateLut: surfaceInfo.iso.duplicateLut
                                        }) )
                                    }
                                }

                                // BBox
                                //console.log(surface)
                                
                                if (surfaceInfo.borders.show) {
                                    const borders = createSurfaceBorders(surface, surfaceInfo.borders.color)
                                    scene.add( borders )
                                }

                                if (surfaceInfo.vectors !== undefined && surfaceInfo.vectors.show === true) {
                                    const vattr = manager.serie(3, surfaceInfo.vectors.attr)
                                    if (vattr) {
                                        scene.add( kepler.createVectors({
                                            geometry: surface.geometry,
                                            vectorField: vattr,
                                            parameters: new kepler.VectorsParameters({
                                                scale: surfaceInfo.vectors.scale,
                                            })
                                        }) )
                                    }
                                }

                                if (attr) {
                                    const minmax = dataframe.array.minMax(attr.array)
                                    //let isos = kepler.generateIsos(minmax[0], minmax[1], 20)
                                    //isos = [-0.2, 0, 0.2]
                                    // let isos = kepler.generateIsos(minmax[0], minmax[1], surfaceInfo.iso.nb)
                                    //let isos = kepler.generateIsosBySpacing(minmax[0], minmax[1], surfaceInfo.iso.spacing)
                                    let iso = undefined
                                    if (surfaceInfo.iso.spacing) {
                                        isos = kepler.generateIsosBySpacing(surfaceInfo.iso.min, surfaceInfo.iso.max, surfaceInfo.iso.spacing)
                                    }
                                    else {
                                        isos = kepler.generateIsos(minmax[0], minmax[1], surfaceInfo.iso.nb)
                                    }

                                    if (surfaceInfo.iso.show) {
                                        const iso = kepler.createIsoContours(
                                            surface,
                                            attr, {
                                                parameters: new kepler.IsoContoursParameters({
                                                    color: '#ffffff',
                                                    lineColor: '#000000',
                                                    isoList: isos,
                                                    filled: surfaceInfo.iso.showFill,
                                                    lined: surfaceInfo.iso.showLines,
                                                    opacity: surfaceInfo.iso.opacity,
                                                    lut: surfaceInfo.lut,
                                                    duplicateLut: surfaceInfo.iso.duplicateLut,
                                                    min: surfaceInfo.iso.min,
                                                    max: surfaceInfo.iso.max
                                                })
                                            }
                                        )
                                        scene.add( iso )
                                        // const cb = new kepler.Colorbar({
                                        //     lutName: surfaceInfo.lut,
                                        //     min: minmax[0],
                                        //     max: minmax[1]
                                        // })
                                        // renderFct.add(cb.render)
                                    }
                                }
                            })
                        })
                    return promise
                }
            }
    }

    </script>
</body>
</html>