<!doctype html>
<html lang="en">
<html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Test Toolbox</title>

<base href="/ui/test-toolbox/">

<head>
    <script src="/api/assets-gateway/raw/package/QHlvdXdvbC9jZG4tY2xpZW50/0.0.3/dist/@youwol/cdn-client.js"></script>
    <script src='/projects/youwol/workspace/packages/kepler/node_modules/three/examples/js/controls/TrackballControls.js'></script>

    <link rel="stylesheet" href="style.css">
</head>


<body>
    <div class="loading" id="js-loader">
        <div class="loader"></div>
    </div>

    <div class='home-container'>
        <span>
            <div class='buttonIcon'>
                <div id='goHome'><i class='fa fa-home'></i></div>
            </div>
            <div class='buttonIcon'>
                <div id='saveHome'><i class='fa fa-clinic-medical'></i></div>
            </div>
            <div class='right-container'>
                <div id='orientCubeWrapper'></div>
            </div>
        </span>
    </div>

    <script type="module">
        let cdn = window['@youwol/cdn-client']
        
        await cdn.fetchBundles({
            '@youwol/dataframe':'0.x',
            '@youwol/math':'0.x',
            '@youwol/attribute':'0.x',
            '@youwol/io':'0.x',
            '@youwol/kepler':'0.x'
        }, window )
      
        await cdn.fetchStyleSheets([
            "fontawesome#5.12.1~css/all.min.css",
        ])

        
        const surfaceset = [
            {
                //url: "/platform/test/geophysics/arche/model_test_sphere/sphere_5120.ts",
                //url: '/platform/test/files/gocad/ts/S1_properties.ts',
                //url: "/platform/test/models/arche/Santos/out/horizon.ts",
                url: "/platform/test/files/gocad/ts/output.ts",
                show: true,
                attr: 'z',
                lut: 'Insar',
                min: 0,
                max: 1,
                isoFill: {
                    opacity: 0.8,
                    show: false,
                    showLines: false,
                    lut: 'Igeoss',
                    nb: 10
                },
                wireframe: {
                    show: false,
                    color: '#000000'
                }
            }
        ]

        let scene, camera, light, renderer, controls, cube, renderFct

        init()
        load()

        function init() {
            scene = new three.Scene
            scene.background = new three.Color( 0xaaaaaa )

            camera = new three.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 100000 )
            camera.position.z = 100

            renderer = new three.WebGLRenderer({alpha: true})
            renderer.setPixelRatio( window.devicePixelRatio )
            renderer.setSize( window.innerWidth, window.innerHeight )
            document.body.appendChild( renderer.domElement )

            renderFct = new kepler.RenderFunctions({renderer, scene, camera})

            window.addEventListener( 'resize', onWindowResize )

            controls = new three.TrackballControls( camera, renderer.domElement )
            // controls.rotateSpeed = 1.0
            // controls.zoomSpeed = 1.2
            // controls.panSpeed = 0.8
            renderFct.add( controls.update )

            const cube = new kepler.installNavigationCube(
                new kepler.NavigationCubeParameters({
                    scene, 
                    camera, 
                    renderer,
                    controls, 
                    renderFunctions: renderFct, // will also add the cube in renderFct
                    labels: ['East', 'West', 'Up', 'Down', 'South', 'North'],

                    domElement : document.getElementById('orientCubeWrapper'),
                    domHome    : document.getElementById('goHome'), 
                    domSaveHome: document.getElementById('saveHome')
                })
            )
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight
            camera.updateProjectionMatrix()
            renderer.setSize( window.innerWidth, window.innerHeight )
            controls.handleResize()
        }

        function animate() {
            //controls.update()
            //renderer.render( scene, camera )
            //cube.update()
            renderFct.render()
            requestAnimationFrame( animate )
        }
        requestAnimationFrame( animate )

        function load() {
            const promises = []

            surfaceset.forEach( surface => {
                if (surface.show===true) {
                    const promise = doSurface(surface)
                    if (promise) {
                        promises.push(promise)
                    }
                }
            })
            
            Promise.all(promises).then( _ => {
                kepler.changeBackground( {scene, color: '#aaaaaa'} )

                scene.add( kepler.createDefaultLights({object: scene, scaling: 10, intensity: 1}) )

                const keyboard = new kepler.Keyboard()
                keyboard.addKey('u', e => kepler.changeView('up', {scene, camera, controls}) )
                keyboard.addKey('d', e => kepler.changeView('down', {scene, camera, controls}) )
                keyboard.addKey('s', e => kepler.changeView('south', {scene, camera, controls}) )
                keyboard.addKey('n', e => kepler.changeView('north', {scene, camera, controls}) )
                keyboard.addKey('e', e => kepler.changeView('east', {scene, camera, controls}) )
                keyboard.addKey('w', e => kepler.changeView('west', {scene, camera, controls}) )
                keyboard.addKey('f', e => kepler.zoomToModel({scene, camera, controls, duration:300}) )

                renderer.domElement.addEventListener('dblclick', event => {
                    kepler.zoomToIntersection( {scene, event, camera, controls} )
                })

                const LOADER = document.getElementById('js-loader');
                LOADER.remove();
            })
            .then( () => {
                kepler.changeView('up', {scene, camera, controls})
            })
        }

        function doSurface(surfaceInfo) {
            const promise = fetch(surfaceInfo.url)
                .then( res => {
                    if ( res.ok ) return res.text()
                    return undefined
                })
                .then( buffer => {
                    if (! buffer) return undefined
                    const dfs = io.decodeGocadTS(buffer, {shared: true, merge: false})
                    dfs.forEach( df => {
                        let skin

                        const manager = new attribute.AttributeManager(df, [
                            new attribute.PositionDecomposer,
                        ])

                        const attr = manager.serie(1, surfaceInfo.attr)

                        if (surfaceInfo.wireframe.show) {
                            scene.add( kepler.createSurface({
                                positions: df.get('positions'),
                                indices  : df.get('indices'),
                                parameters: new kepler.SurfaceParameters({
                                    wireframe: true, 
                                    color: surfaceInfo.wireframe.color,
                                    opacity: 1.0
                                })
                            }) )
                        }
                        
                        // surface
                        const surface = kepler.createSurface({
                            positions: df.get('positions'),
                            indices  : df.get('indices'),
                            parameters: new kepler.SurfaceParameters({
                                flat: false, 
                                wireframe: false, 
                                color: '#aaaaaa',
                                opacity: 1.0,
                                creaseAngle: 0
                            })
                        })
                        if (surfaceInfo.isoFill.show===false) {
                            scene.add(surface)
                            if (attr) {
                                kepler.paintAttribute( surface, attr, new kepler.PaintParameters({
                                    atVertex: true
                                }) )
                            }
                        }

                        // BBox
                        scene.add( kepler.createBBox(surface) )

                        if (attr) {
                            if (surfaceInfo.isoFill.show) {
                                scene.add( kepler.createIsoContours(
                                    surface,
                                    attr, {
                                        parameters: new kepler.IsoContoursParameters({
                                            color: '#ffffff',
                                            nbr: 10,
                                            filled: true,
                                            opacity: 1
                                        })
                                    }
                                ) )
                            }
                            scene.add( kepler.createIsoContours(
                                surface,
                                attr, {
                                    parameters: new kepler.IsoContoursParameters({
                                        color: '#000000',
                                        nbr: 10,
                                        filled: false,
                                        opacity: 1
                                    })
                                })
                            )
                        }
                    })
                })
            return promise
        }
    </script>
  </body>
</html>